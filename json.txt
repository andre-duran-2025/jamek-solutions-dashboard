[
    {
        "id": "multi_inv_tab",
        "type": "tab",
        "label": "MULTI-INVERSOR 21x",
        "disabled": false,
        "info": "Flow completo para controle de 21 inversores via MQTT e WebSocket"
    },
    {
        "id": "mqtt_broker",
        "type": "mqtt-broker",
        "name": "Broker Principal",
        "broker": "localhost",
        "port": 1883,
        "clientid": "nodered_multi_inv",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true
    },
    {
        "id": "ws_listener",
        "type": "websocket-listener",
        "path": "api/ws/inversor",
        "wholemsg": "false"
    },
    {
        "id": "ws_in",
        "type": "websocket in",
        "z": "multi_inv_tab",
        "name": "WS Comandos",
        "server": "ws_listener",
        "client": "",
        "x": 120,
        "y": 60,
        "wires": [["validacao_cmd"]]
    },
    {
        "id": "validacao_cmd",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Valida√ß√£o Completa",
        "func": "// Parse JSON\nif (typeof msg.payload === \"string\") {\n    try {\n        msg.payload = JSON.parse(msg.payload);\n    } catch (e) {\n        node.error(\"JSON inv√°lido\", msg);\n        return [null, { payload: { erro: \"JSON inv√°lido\" } }];\n    }\n}\n\nconst { inv, cmd, value } = msg.payload;\n\n// Valida campos obrigat√≥rios\nif (inv === undefined || cmd === undefined) {\n    return [null, { payload: { erro: \"Campos 'inv' e 'cmd' obrigat√≥rios\" } }];\n}\n\n// Valida ID (1-21)\nif (inv < 1 || inv > 21) {\n    return [null, { payload: { erro: `ID inv√°lido: ${inv} (deve ser 1-21)` } }];\n}\n\n// Valida comandos\nswitch (cmd) {\n    case \"start\":\n    case \"stop\":\n    case \"direcao\":\n    case \"reset\":\n        // Sem valida√ß√£o adicional\n        break;\n        \n    case \"freq\":\n    case \"frequencia\":\n        if (value === undefined || value < 0 || value > 60) {\n            return [null, { payload: { erro: `Frequ√™ncia inv√°lida: ${value} (0-60Hz)` } }];\n        }\n        break;\n        \n    default:\n        return [null, { payload: { erro: `Comando desconhecido: ${cmd}` } }];\n}\n\n// Log\nnode.log(`‚úÖ CMD v√°lido: INV${inv} - ${cmd} ${value !== undefined ? '= ' + value : ''}`);\n\n// Retorna [v√°lido, erro]\nreturn [msg, null];",
        "outputs": 2,
        "outputLabels": ["V√°lido", "Erro"],
        "x": 320,
        "y": 60,
        "wires": [["mqtt_cmd_format", "log_cmds"], ["ws_erro"]]
    },
    {
        "id": "mqtt_cmd_format",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Formata MQTT",
        "func": "const { inv, cmd, value } = msg.payload;\nlet out = {};\n\nswitch (cmd) {\n    case \"start\":\n        out.topic = `inversor/${inv}/cmd/start`;\n        out.payload = \"1\";\n        break;\n\n    case \"stop\":\n        out.topic = `inversor/${inv}/cmd/stop`;\n        out.payload = \"1\";\n        break;\n\n    case \"freq\":\n    case \"frequencia\":\n        out.topic = `inversor/${inv}/cmd/frequencia`;\n        out.payload = String(value);\n        break;\n\n    case \"direcao\":\n        out.topic = `inversor/${inv}/cmd/direcao`;\n        out.payload = \"1\";\n        break;\n        \n    case \"reset\":\n        out.topic = `inversor/${inv}/cmd/reset`;\n        out.payload = \"1\";\n        break;\n\n    default:\n        return null;\n}\n\nreturn out;",
        "outputs": 1,
        "x": 540,
        "y": 60,
        "wires": [["mqtt_out"]]
    },
    {
        "id": "mqtt_out",
        "type": "mqtt out",
        "z": "multi_inv_tab",
        "name": "Publica Comandos",
        "topic": "",
        "qos": "1",
        "retain": "",
        "broker": "mqtt_broker",
        "x": 760,
        "y": 60,
        "wires": []
    },
    {
        "id": "mqtt_status",
        "type": "mqtt in",
        "z": "multi_inv_tab",
        "name": "Status Inversores",
        "topic": "inversor/+/status/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 180,
        "wires": [["cache_status"]]
    },
    {
        "id": "cache_status",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Cache Inteligente",
        "func": "// Inicializa cache global\nif (!flow.get('inversores')) {\n    const inv = {};\n    for (let i = 1; i <= 21; i++) {\n        inv[i] = {\n            id: i,\n            online: false,\n            rodando: false,\n            frequencia: 0,\n            frequencia_setpoint: 0,\n            corrente: 0,\n            direcao: \"frente\",\n            ultima_atualizacao: 0\n        };\n    }\n    flow.set('inversores', inv);\n}\n\nconst inversores = flow.get('inversores');\n\n// Parse t√≥pico: inversor/{id}/status/{campo}\nconst match = msg.topic.match(/inversor\\/(\\d+)\\/status\\/(.+)/);\n\nif (match) {\n    const invId = parseInt(match[1]);\n    const campo = match[2];\n    \n    if (invId >= 1 && invId <= 21) {\n        inversores[invId][campo] = msg.payload;\n        inversores[invId].ultima_atualizacao = Date.now();\n        \n        flow.set('inversores', inversores);\n        \n        // Retorna status completo do inversor\n        return {\n            payload: {\n                inv: invId,\n                ...inversores[invId]\n            },\n            topic: `status_update_${invId}`\n        };\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "x": 350,
        "y": 180,
        "wires": [["ws_out", "dashboard_update"]]
    },
    {
        "id": "ws_out",
        "type": "websocket out",
        "z": "multi_inv_tab",
        "name": "WS Status",
        "server": "ws_listener",
        "client": "",
        "x": 730,
        "y": 180,
        "wires": []
    },
    {
        "id": "mqtt_erros",
        "type": "mqtt in",
        "z": "multi_inv_tab",
        "name": "Erros Inversores",
        "topic": "inversor/+/erro",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "inputs": 0,
        "x": 130,
        "y": 240,
        "wires": [["log_erros", "ws_erro"]]
    },
    {
        "id": "ws_erro",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Formata Erro",
        "func": "let invId = null;\n\nif (msg.topic) {\n    const match = msg.topic.match(/inversor\\/(\\d+)\\/erro/);\n    if (match) invId = parseInt(match[1]);\n}\n\nreturn {\n    payload: {\n        tipo: 'erro',\n        inversor: invId,\n        mensagem: msg.payload.erro || msg.payload,\n        timestamp: new Date().toISOString()\n    }\n};",
        "outputs": 1,
        "x": 540,
        "y": 240,
        "wires": [["ws_out"]]
    },
    {
        "id": "mqtt_heartbeat",
        "type": "mqtt in",
        "z": "multi_inv_tab",
        "name": "Gateway Heartbeat",
        "topic": "inversor/gateway/heartbeat",
        "qos": "0",
        "datatype": "json",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "inputs": 0,
        "x": 150,
        "y": 300,
        "wires": [["heartbeat_proc"]]
    },
    {
        "id": "heartbeat_proc",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Processa Heartbeat",
        "func": "const data = msg.payload;\n\nconst status = {\n    tipo: 'gateway_status',\n    online: true,\n    uptime: data.uptime,\n    free_heap: data.free_heap,\n    wifi_rssi: data.wifi_rssi,\n    inversores_online: data.inversores_online || 0,\n    timestamp: new Date().toISOString()\n};\n\nflow.set('gateway_status', status);\n\n// Alertas\nif (data.free_heap < 50000) {\n    node.warn(`‚ö†Ô∏è  Heap baixo: ${data.free_heap} bytes`);\n}\n\nif (data.wifi_rssi < -80) {\n    node.warn(`‚ö†Ô∏è  WiFi fraco: ${data.wifi_rssi} dBm`);\n}\n\nreturn { payload: status };",
        "outputs": 1,
        "x": 380,
        "y": 300,
        "wires": [["ws_out"]]
    },
    {
        "id": "mqtt_stats",
        "type": "mqtt in",
        "z": "multi_inv_tab",
        "name": "Gateway Stats",
        "topic": "inversor/gateway/stats",
        "qos": "0",
        "datatype": "json",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "inputs": 0,
        "x": 140,
        "y": 360,
        "wires": [["stats_proc"]]
    },
    {
        "id": "stats_proc",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Processa Stats",
        "func": "return {\n    payload: {\n        tipo: 'gateway_stats',\n        ...msg.payload,\n        timestamp: new Date().toISOString()\n    }\n};",
        "outputs": 1,
        "x": 360,
        "y": 360,
        "wires": [["ws_out"]]
    },
    {
        "id": "log_cmds",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Log Comandos",
        "func": "const log = {\n    timestamp: new Date().toISOString(),\n    inversor: msg.payload.inv,\n    comando: msg.payload.cmd,\n    valor: msg.payload.value,\n    origem: 'websocket'\n};\n\nlet logs = context.get('logs') || [];\nlogs.push(log);\n\n// Mant√©m √∫ltimas 1000 entradas\nif (logs.length > 1000) {\n    logs = logs.slice(-1000);\n}\n\ncontext.set('logs', logs);\nnode.log(JSON.stringify(log));\n\nreturn null;",
        "outputs": 0,
        "x": 540,
        "y": 120,
        "wires": []
    },
    {
        "id": "log_erros",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Log Erros",
        "func": "const match = msg.topic.match(/inversor\\/(\\d+)\\/erro/);\nconst invId = match ? parseInt(match[1]) : null;\n\nconst log = {\n    timestamp: new Date().toISOString(),\n    inversor: invId,\n    erro: msg.payload,\n    nivel: 'error'\n};\n\nlet erros = context.get('erros') || [];\nerros.push(log);\n\nif (erros.length > 500) {\n    erros = erros.slice(-500);\n}\n\ncontext.set('erros', erros);\nnode.error(`‚ùå INV${invId}: ${msg.payload}`, msg);\n\nreturn null;",
        "outputs": 0,
        "x": 530,
        "y": 280,
        "wires": []
    },
    {
        "id": "watchdog",
        "type": "inject",
        "z": "multi_inv_tab",
        "name": "Watchdog 60s",
        "props": [],
        "repeat": "60",
        "crontab": "",
        "once": false,
        "x": 130,
        "y": 420,
        "wires": [["check_timeout"]]
    },
    {
        "id": "check_timeout",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Verifica Timeout",
        "func": "const gateway = flow.get('gateway_status');\nconst inversores = flow.get('inversores') || {};\nconst now = Date.now();\n\n// Verifica gateway offline\nif (!gateway || now - new Date(gateway.timestamp).getTime() > 90000) {\n    node.warn('üî¥ Gateway ESP32 offline h√° mais de 90s!');\n    \n    return {\n        payload: {\n            tipo: 'alerta',\n            severidade: 'critico',\n            mensagem: 'Gateway ESP32 offline',\n            timestamp: new Date().toISOString()\n        }\n    };\n}\n\n// Verifica inversores sem atualiza√ß√£o h√° muito tempo\nconst alertas = [];\nfor (let id in inversores) {\n    const inv = inversores[id];\n    if (inv.online && now - inv.ultima_atualizacao > 120000) {\n        alertas.push({\n            tipo: 'alerta',\n            severidade: 'aviso',\n            mensagem: `Inversor ${id} sem atualiza√ß√£o h√° 2min`,\n            timestamp: new Date().toISOString()\n        });\n    }\n}\n\nif (alertas.length > 0) {\n    return alertas.map(a => ({ payload: a }));\n}\n\nreturn null;",
        "outputs": 1,
        "x": 350,
        "y": 420,
        "wires": [["ws_out"]]
    },
    {
        "id": "dashboard_update",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Dashboard Update",
        "func": "// Este n√≥ pode ser conectado a widgets do node-red-dashboard\n// Exemplo de sa√≠das para diferentes widgets\n\nconst inv = msg.payload;\nconst id = inv.inv || inv.id;\n\nif (!id) return null;\n\n// Retorna m√∫ltiplas sa√≠das para diferentes widgets\nreturn [\n    { payload: inv.online === \"1\" || inv.online === true, topic: `inv${id}_online` },\n    { payload: inv.rodando === \"1\" || inv.rodando === true, topic: `inv${id}_rodando` },\n    { payload: parseFloat(inv.frequencia) || 0, topic: `inv${id}_freq` },\n    { payload: parseFloat(inv.corrente) || 0, topic: `inv${id}_corrente` },\n    { payload: inv.direcao || \"frente\", topic: `inv${id}_direcao` }\n];",
        "outputs": 5,
        "x": 570,
        "y": 180,
        "wires": [[], [], [], [], []]
    },
    {
        "id": "api_status_all",
        "type": "http in",
        "z": "multi_inv_tab",
        "name": "",
        "url": "/api/inversor/status",
        "method": "get",
        "x": 150,
        "y": 500,
        "wires": [["get_all_status"]]
    },
    {
        "id": "get_all_status",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Get All Status",
        "func": "const inversores = flow.get('inversores') || {};\nconst gateway = flow.get('gateway_status');\n\nmsg.payload = {\n    gateway: gateway || { online: false },\n    inversores: Object.values(inversores),\n    timestamp: new Date().toISOString()\n};\n\nmsg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "x": 370,
        "y": 500,
        "wires": [["api_response"]]
    },
    {
        "id": "api_status_id",
        "type": "http in",
        "z": "multi_inv_tab",
        "name": "",
        "url": "/api/inversor/:id/status",
        "method": "get",
        "x": 160,
        "y": 560,
        "wires": [["get_id_status"]]
    },
    {
        "id": "get_id_status",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Get ID Status",
        "func": "const invId = parseInt(msg.req.params.id);\nconst inversores = flow.get('inversores') || {};\n\nif (invId < 1 || invId > 21) {\n    msg.statusCode = 400;\n    msg.payload = { erro: `ID inv√°lido: ${invId}` };\n    return msg;\n}\n\nif (inversores[invId]) {\n    msg.payload = inversores[invId];\n    msg.statusCode = 200;\n} else {\n    msg.statusCode = 404;\n    msg.payload = { erro: `Inversor ${invId} n√£o encontrado` };\n}\n\nreturn msg;",
        "outputs": 1,
        "x": 390,
        "y": 560,
        "wires": [["api_response"]]
    },
    {
        "id": "api_cmd",
        "type": "http in",
        "z": "multi_inv_tab",
        "name": "",
        "url": "/api/inversor/:id/cmd",
        "method": "post",
        "x": 150,
        "y": 620,
        "wires": [["post_cmd"]]
    },
    {
        "id": "post_cmd",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Post Command",
        "func": "const invId = parseInt(msg.req.params.id);\nconst body = msg.payload;\n\nif (!body || !body.cmd) {\n    msg.statusCode = 400;\n    msg.payload = { erro: \"Campo 'cmd' obrigat√≥rio\" };\n    return [null, msg];\n}\n\nif (invId < 1 || invId > 21) {\n    msg.statusCode = 400;\n    msg.payload = { erro: `ID inv√°lido: ${invId}` };\n    return [null, msg];\n}\n\n// Prepara para valida√ß√£o\nmsg.payload = {\n    inv: invId,\n    cmd: body.cmd,\n    value: body.value\n};\n\n// Marca para resposta HTTP\nmsg.isApiRequest = true;\n\nreturn [msg, null];",
        "outputs": 2,
        "x": 360,
        "y": 620,
        "wires": [["validacao_cmd"], ["api_response"]]
    },
    {
        "id": "api_response",
        "type": "http response",
        "z": "multi_inv_tab",
        "name": "API Response",
        "x": 610,
        "y": 560,
        "wires": []
    },
    {
        "id": "api_logs",
        "type": "http in",
        "z": "multi_inv_tab",
        "name": "",
        "url": "/api/logs",
        "method": "get",
        "x": 120,
        "y": 680,
        "wires": [["get_logs"]]
    },
    {
        "id": "get_logs",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Get Logs",
        "func": "const logs = context.get('logs') || [];\nconst limit = parseInt(msg.req.query.limit) || 100;\n\nmsg.payload = {\n    logs: logs.slice(-limit),\n    total: logs.length,\n    timestamp: new Date().toISOString()\n};\n\nmsg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "x": 340,
        "y": 680,
        "wires": [["api_response"]]
    },
    {
        "id": "api_erros",
        "type": "http in",
        "z": "multi_inv_tab",
        "name": "",
        "url": "/api/erros",
        "method": "get",
        "x": 120,
        "y": 740,
        "wires": [["get_erros"]]
    },
    {
        "id": "get_erros",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Get Erros",
        "func": "const erros = context.get('erros') || [];\nconst limit = parseInt(msg.req.query.limit) || 50;\n\nmsg.payload = {\n    erros: erros.slice(-limit),\n    total: erros.length,\n    timestamp: new Date().toISOString()\n};\n\nmsg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "x": 340,
        "y": 740,
        "wires": [["api_response"]]
    },
    {
        "id": "init_flow",
        "type": "inject",
        "z": "multi_inv_tab",
        "name": "Inicializar Cache",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "x": 140,
        "y": 800,
        "wires": [["cache_init"]]
    },
    {
        "id": "cache_init",
        "type": "function",
        "z": "multi_inv_tab",
        "name": "Init Cache",
        "func": "// Inicializa cache de inversores\nconst inversores = {};\nfor (let i = 1; i <= 21; i++) {\n    inversores[i] = {\n        id: i,\n        online: false,\n        rodando: false,\n        frequencia: 0,\n        frequencia_setpoint: 0,\n        corrente: 0,\n        direcao: \"frente\",\n        ultima_atualizacao: 0\n    };\n}\n\nflow.set('inversores', inversores);\nflow.set('gateway_status', { online: false });\n\nnode.log('‚úÖ Cache inicializado para 21 inversores');\n\nreturn null;",
        "outputs": 0,
        "x": 350,
        "y": 800,
        "wires": []
    }
]